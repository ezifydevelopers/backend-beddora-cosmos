// Prisma Schema for Beddora SaaS
// Enhanced schema with authentication, authorization, and multi-account support

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// AUTHENTICATION & AUTHORIZATION
// ============================================

model User {
  id            String   @id @default(uuid())
  email         String   @unique
  password      String
  name          String?
  isActive      Boolean  @default(true)
  isVerified    Boolean  @default(false) @map("emailVerified")
  verifiedAt    DateTime? @map("emailVerifiedAt")
  termsAccepted Boolean  @default(false)
  twoFactorEnabled Boolean @default(false)
  twoFactorSecret String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  roles         UserRole[]
  userAccounts  UserAccount[]
  userPermissions UserPermission[]
  refreshTokens RefreshToken[]
  emailVerifications EmailVerification[]
  passwordResets PasswordReset[]
  auditLogs     AuditLog[]
  amazonAccounts AmazonAccount[]
  syncLogs       SyncLog[]
  orderImports   OrderImportStaging[]
  ppcImports     PPCImportStaging[]
  inventoryImports InventoryImportStaging[]
  listingImports ListingImportStaging[]
  refundImports  RefundImportStaging[]
  reportSchedules ReportSchedule[]
  ppcBulkHistory PPCBulkHistory[]
  listingAlerts ListingAlert[]
  buyBoxAlerts BuyBoxAlert[]
  feeChangeAlerts FeeChangeAlert[]
  feedbackReviewAlerts FeedbackReviewAlert[]
  emailTemplates EmailTemplate[]
  schedulingRules SchedulingRule[]
  reviewStats ReviewStats[]
  fbaInventoryAlerts FbaInventoryAlert[]
  refundDiscrepancies RefundDiscrepancy[]
  refundDiscrepancyHistory RefundDiscrepancyHistory[]
  reimbursementCases ReimbursementCase[]
  caseHistory CaseHistory[]
  userMarketplaces UserMarketplace[]
  oauthStates OAuthState[]
  syncSchedules SyncSchedule[]

  @@index([email])
  @@map("users")
}

model Role {
  id          String   @id @default(uuid())
  name        String   @unique // 'ADMIN', 'MANAGER', 'VIEWER'
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  users       UserRole[]
  permissions RolePermission[]

  @@map("roles")
}

model Permission {
  id          String   @id @default(uuid())
  name        String   @unique // 'profit.read', 'inventory.write', etc.
  resource    String   // 'profit', 'inventory', 'ppc', 'alerts'
  action      String   // 'read', 'write', 'delete', 'none'
  description String?
  scope       PermissionScope @default(GLOBAL) // GLOBAL, MARKETPLACE, PRODUCT
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  rolePermissions RolePermission[]
  userPermissions UserPermission[]

  @@index([resource, action])
  @@map("permissions")
}

model UserRole {
  id        String   @id @default(uuid())
  userId    String
  roleId    String
  accountId String?
  createdAt DateTime @default(now())

  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role      Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  account   Account? @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId, accountId])
  @@map("user_roles")
}

model RolePermission {
  id           String   @id @default(uuid())
  roleId       String
  permissionId String
  scope        PermissionScope @default(GLOBAL)
  marketplaceId String?
  productId    String?
  createdAt    DateTime @default(now())

  // Relations
  role         Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  marketplace  Marketplace? @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)
  product      Product? @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId, marketplaceId, productId])
  @@map("role_permissions")
}

model UserPermission {
  id           String   @id @default(uuid())
  userId       String
  accountId    String?  // Null for global permissions, set for account-specific
  permissionId String
  createdAt    DateTime @default(now())

  // Relations
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  account      Account? @relation(fields: [accountId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([userId, accountId, permissionId])
  @@index([userId, accountId])
  @@map("user_permissions")
}

enum PermissionScope {
  GLOBAL
  MARKETPLACE
  PRODUCT
}

// ============================================
// TOKEN MANAGEMENT
// ============================================

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  isRevoked Boolean  @default(false)
  createdAt DateTime @default(now())

  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model EmailVerification {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  usedAt    DateTime?
  createdAt DateTime @default(now())

  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("email_verifications")
}

model PasswordReset {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  usedAt    DateTime?
  createdAt DateTime @default(now())

  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("password_resets")
}

// ============================================
// ACCOUNTS & MARKETPLACES
// ============================================

model Account {
  id          String   @id @default(uuid())
  name        String
  sellerId    String?  // Amazon Seller ID
  region      String?  // 'us', 'eu', 'uk', etc.
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  userAccounts UserAccount[]
  userRoles    UserRole[]
  marketplaces AccountMarketplace[]
  userPermissions UserPermission[]
  products    Product[]
  orders      Order[]
  returns     Return[]
  ppcCampaigns PPC_Campaign[]
  expenses    Expense[]
  cashflow    Cashflow[]
  cogs        COGS[]
  batches     Batch[]
  reportSchedules ReportSchedule[]
  inventoryStock InventoryStock[]
  inventoryForecasts InventoryForecast[]
  inventoryKpis InventoryKPI[]
  ppcDashboardCampaigns PPCCampaign[]
  ppcDashboardAdGroups PPCAdGroup[]
  ppcDashboardKeywords PPCKeyword[]
  ppcBulkHistory PPCBulkHistory[]
  schedulingRules SchedulingRule[]
  reviewStats ReviewStats[]
  fbaInventoryAlerts FbaInventoryAlert[]
  refundDiscrepancies RefundDiscrepancy[]
  reimbursementCases ReimbursementCase[]

  @@index([sellerId])
  @@map("accounts")
}

model Marketplace {
  id          String   @id @default(uuid())
  name        String   @unique
  code        String   @unique // 'amazon', 'ebay', etc.
  region      String?
  baseCurrency String? // e.g., 'USD', 'EUR', 'GBP'
  currency    String?  // e.g., 'USD', 'EUR', 'GBP'
  timezone    String?  // e.g., 'America/Los_Angeles'
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  accountMarketplaces AccountMarketplace[]
  rolePermissions RolePermission[]
  orders Order[] @relation("MarketplaceOrders")
  expenses Expense[] @relation("MarketplaceExpenses")
  returns Return[] @relation("MarketplaceReturns")
  cogs COGS[]
  inventoryStock InventoryStock[]
  inventoryForecasts InventoryForecast[]
  purchaseOrders PurchaseOrder[]
  inventoryKpis InventoryKPI[]
  ppcDashboardCampaigns PPCCampaign[]
  ppcDashboardAdGroups PPCAdGroup[]
  ppcDashboardKeywords PPCKeyword[]
  listingAlerts ListingAlert[]
  listingHistory ListingHistory[]
  buyBoxAlerts BuyBoxAlert[]
  buyBoxHistory BuyBoxHistory[]
  feeChangeAlerts FeeChangeAlert[]
  feeChangeHistory FeeChangeHistory[]
  feedbackReviewAlerts FeedbackReviewAlert[]
  feedbackReviewHistory FeedbackReviewHistory[]
  emailTemplates EmailTemplate[]
  schedulingRules SchedulingRule[]
  reviewStats ReviewStats[]
  fbaInventoryAlerts FbaInventoryAlert[]
  refundDiscrepancies RefundDiscrepancy[]
  reimbursementCases ReimbursementCase[]
  userMarketplaces UserMarketplace[]

  @@map("marketplaces")
}

// ============================================
// MULTI-CURRENCY
// ============================================

model Currency {
  id             String   @id @default(uuid())
  code           String   @unique // USD, GBP, EUR
  name           String
  symbol         String?
  isBaseCurrency Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  fromCurrencyRates ExchangeRate[] @relation("FromCurrency")
  toCurrencyRates   ExchangeRate[] @relation("ToCurrency")

  @@index([code])
  @@index([isBaseCurrency])
  @@map("currencies")
}

model ExchangeRate {
  id             String   @id @default(uuid())
  fromCurrencyId String
  toCurrencyId   String
  rate           Decimal  @default(1)
  fetchedAt      DateTime @default(now())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  fromCurrency   Currency @relation("FromCurrency", fields: [fromCurrencyId], references: [id], onDelete: Cascade)
  toCurrency     Currency @relation("ToCurrency", fields: [toCurrencyId], references: [id], onDelete: Cascade)

  @@index([fromCurrencyId])
  @@index([toCurrencyId])
  @@index([fetchedAt])
  @@map("exchange_rates")
}

model UserAccount {
  id          String   @id @default(uuid())
  userId      String
  accountId   String
  isActive    Boolean  @default(true)
  isDefault   Boolean  @default(false) // Default account for user
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  account     Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([userId, accountId])
  @@index([userId])
  @@index([accountId])
  @@map("user_accounts")
}

model AccountMarketplace {
  id           String   @id @default(uuid())
  accountId    String
  marketplaceId String
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  account      Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace  Marketplace @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)

  @@unique([accountId, marketplaceId])
  @@index([accountId])
  @@index([marketplaceId])
  @@map("account_marketplaces")
}

model UserMarketplace {
  id              String   @id @default(uuid())
  userId          String
  marketplaceId   String
  amazonAccountId String?
  credentials     Json?    // Encrypted API credentials
  linkedAt        DateTime @default(now())
  status          String   @default("active") // 'active', 'inactive'
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  marketplace     Marketplace  @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)
  amazonAccount   AmazonAccount? @relation(fields: [amazonAccountId], references: [id], onDelete: SetNull)

  @@unique([userId, marketplaceId])
  @@index([userId])
  @@index([marketplaceId])
  @@index([amazonAccountId])
  @@map("user_marketplaces")
}

// ============================================
// PRODUCTS & INVENTORY
// ============================================

model Product {
  id              String   @id @default(uuid())
  accountId       String
  sku             String
  asin            String?
  title           String
  imageUrl        String?
  category        String?
  brand           String?
  currentPrice    Decimal  @default(0)
  cost            Decimal  @default(0)
  quantity        Int      @default(0)
  reorderLevel    Int      @default(10)
  status          String   @default("active")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  account         Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  orderItems      OrderItem[]
  inventory       Inventory[]
  purchaseOrders  PurchaseOrderItem[]
  rolePermissions RolePermission[]
  feeChangeAlerts FeeChangeAlert[]
  feeChangeHistory FeeChangeHistory[]
  feedbackReviewAlerts FeedbackReviewAlert[]
  feedbackReviewHistory FeedbackReviewHistory[]
  emailTemplates EmailTemplate[]
  schedulingRules SchedulingRule[]
  reviewStats ReviewStats[]
  fbaInventoryAlerts FbaInventoryAlert[]
  refundDiscrepancies RefundDiscrepancy[]
  reimbursementCases ReimbursementCase[]

  @@unique([accountId, sku])
  @@index([accountId])
  @@index([asin])
  @@map("products")
}

model Inventory {
  id          String   @id @default(uuid())
  productId   String
  quantity    Int
  changeType  String
  notes       String?
  createdAt   DateTime @default(now())

  // Relations
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@map("inventory")
}

model InventoryStock {
  id               String   @id @default(uuid())
  sku              String
  accountId        String
  marketplaceId    String?
  amazonAccountId  String?
  quantityAvailable Int     @default(0)
  quantityReserved  Int     @default(0)
  lowStockThreshold Int     @default(10)
  lastSyncedAt     DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  account       Account      @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace   Marketplace? @relation(fields: [marketplaceId], references: [id], onDelete: SetNull)
  amazonAccount AmazonAccount? @relation(fields: [amazonAccountId], references: [id], onDelete: SetNull)

  @@unique([accountId, sku, marketplaceId])
  @@index([accountId])
  @@index([sku])
  @@index([marketplaceId])
  @@index([accountId, sku, marketplaceId])
  @@map("inventory_stock")
}

model InventoryForecast {
  id               String   @id @default(uuid())
  sku              String
  accountId        String
  marketplaceId    String?
  currentStock     Int      @default(0)
  salesVelocity    Decimal  @default(0) // units per day
  forecast3Day     Decimal  @default(0)
  forecast7Day     Decimal  @default(0)
  forecast30Day    Decimal  @default(0)
  restockThreshold Int      @default(0)
  alertSent        Boolean  @default(false)
  lastCalculatedAt DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  account       Account      @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace   Marketplace? @relation(fields: [marketplaceId], references: [id], onDelete: SetNull)

  @@unique([accountId, sku, marketplaceId])
  @@index([accountId])
  @@index([sku])
  @@index([marketplaceId])
  @@index([accountId, sku, marketplaceId])
  @@map("inventory_forecasts")
}

model InventoryKPI {
  id                   String   @id @default(uuid())
  sku                  String
  accountId            String
  marketplaceId        String?
  daysOfStockLeft      Decimal  @default(0)
  overstockRisk        Boolean  @default(false)
  fifoBatchAssignments Json?
  lastCalculatedAt     DateTime?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Relations
  account       Account      @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace   Marketplace? @relation(fields: [marketplaceId], references: [id], onDelete: SetNull)

  @@unique([accountId, sku, marketplaceId])
  @@index([accountId])
  @@index([sku])
  @@index([marketplaceId])
  @@index([accountId, sku, marketplaceId])
  @@map("inventory_kpis")
}

model Supplier {
  id            String   @id @default(uuid())
  name          String
  contactInfo   Json?
  leadTimeDays  Int      @default(14)
  email         String?
  phone         String?
  address       String?
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  purchaseOrders PurchaseOrder[]

  @@map("suppliers")
}

model PurchaseOrder {
  id                    String   @id @default(uuid())
  supplierId            String
  accountId             String
  marketplaceId         String?
  poNumber              String   @unique
  status                String   @default("pending") // pending, in-transit, received, canceled
  estimatedDeliveryDate DateTime?
  totalQuantity         Int      @default(0)
  totalCost             Decimal  @default(0)
  orderDate             DateTime @default(now())
  receivedDate          DateTime?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Relations
  supplier      Supplier      @relation(fields: [supplierId], references: [id])
  marketplace   Marketplace?  @relation(fields: [marketplaceId], references: [id], onDelete: SetNull)
  items         PurchaseOrderItem[]
  inboundShipments InboundShipment[]

  @@index([supplierId])
  @@index([accountId])
  @@index([marketplaceId])
  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id              String   @id @default(uuid())
  purchaseOrderId String
  productId       String?
  sku             String
  quantity        Int
  unitCost        Decimal
  totalCost       Decimal
  createdAt       DateTime @default(now())

  // Relations
  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  product         Product?      @relation(fields: [productId], references: [id])

  @@index([purchaseOrderId])
  @@index([productId])
  @@index([sku])
  @@map("purchase_order_items")
}

model InboundShipment {
  id               String   @id @default(uuid())
  purchaseOrderId  String
  sku              String
  quantityShipped  Int
  quantityReceived Int      @default(0)
  shipmentDate     DateTime @default(now())
  receivedDate     DateTime?
  status           String   @default("pending") // pending, in-transit, received

  // Relations
  purchaseOrder    PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)

  @@index([purchaseOrderId])
  @@index([sku])
  @@map("inbound_shipments")
}

// ============================================
// ORDERS & SALES
// ============================================

model Order {
  id              String   @id @default(uuid())
  accountId       String
  marketplaceId   String?  // Links to Marketplace for profit breakdown
  orderId         String   @unique
  orderDate       DateTime
  shipDate        DateTime?
  orderStatus     String
  totalAmount     Decimal  @default(0)
  shippingCost    Decimal  @default(0)
  tax             Decimal  @default(0)
  currency        String   @default("USD")
  marketplace     String?  // Legacy field, kept for backward compatibility
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  account         Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplaceRef  Marketplace? @relation("MarketplaceOrders", fields: [marketplaceId], references: [id], onDelete: SetNull)
  items           OrderItem[]
  fees            Fee[]
  refunds         Refund[]
  returns         Return[]

  @@index([accountId])
  @@index([orderId])
  @@index([marketplaceId])
  @@index([orderDate])
  @@index([accountId, orderDate])
  @@map("orders")
}

model OrderItem {
  id              String   @id @default(uuid())
  orderId         String
  productId       String
  sku             String
  quantity        Int
  unitPrice       Decimal
  totalPrice      Decimal
  createdAt       DateTime @default(now())

  // Relations
  order           Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product         Product  @relation(fields: [productId], references: [id])

  @@index([orderId])
  @@index([productId])
  @@index([sku])
  @@index([sku, createdAt])
  @@map("order_items")
}

model Fee {
  id          String   @id @default(uuid())
  orderId     String
  feeType     String   // 'FBA', 'Referral', 'Shipping', etc.
  amount      Decimal
  description String?
  timestamp   DateTime @default(now()) // For FBA fees aggregation by period
  createdAt   DateTime @default(now())

  // Relations
  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([feeType])
  @@index([timestamp])
  @@index([feeType, timestamp])
  @@map("fees")
}

model Refund {
  id          String   @id @default(uuid())
  orderId     String
  refundId    String   @unique
  amount      Decimal
  reason      String?
  reasonCode  String?  // Added per requirements
  status      String   @default("pending")
  refundDate DateTime @default(now())
  processedAt DateTime? // Added per requirements
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([createdAt])
  @@map("refunds")
}

model Return {
  id               String   @id @default(uuid())
  orderId          String
  sku              String
  accountId        String
  marketplaceId    String?
  quantityReturned Int
  reasonCode       String
  refundAmount     Decimal
  feeAmount        Decimal
  isSellable       Boolean  @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  order            Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  account          Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace      Marketplace? @relation("MarketplaceReturns", fields: [marketplaceId], references: [id], onDelete: SetNull)

  @@index([accountId])
  @@index([sku])
  @@index([reasonCode])
  @@index([marketplaceId])
  @@index([createdAt])
  @@map("returns")
}

// ============================================
// PPC & ADVERTISING
// ============================================

model PPC_Campaign {
  id              String   @id @default(uuid())
  accountId       String
  campaignId      String
  name            String
  platform        String   @default("amazon")
  status          String   @default("active")
  budget          Decimal  @default(0)
  spend           Decimal  @default(0)
  impressions     Int      @default(0)
  clicks          Int      @default(0)
  conversions     Int      @default(0)
  acos            Decimal?
  roas            Decimal?
  startDate       DateTime
  endDate         DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  account         Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([accountId])
  @@index([campaignId])
  @@map("ppc_campaigns")
}

// ============================================
// EXPENSES & CASHFLOW
// ============================================

model Expense {
  id            String   @id @default(uuid())
  accountId     String
  marketplaceId String?  // Links to Marketplace for profit breakdown
  type          String   // 'fixed', 'recurring', 'one-time'
  category      String
  amount        Decimal
  currency      String
  allocatedProducts Json? // JSON array of { sku, percentage }
  description   String?
  incurredAt    DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  account       Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace   Marketplace? @relation("MarketplaceExpenses", fields: [marketplaceId], references: [id], onDelete: SetNull)

  @@index([accountId])
  @@index([marketplaceId])
  @@index([incurredAt])
  @@index([accountId, incurredAt])
  @@index([type])
  @@index([category])
  @@map("expenses")
}

model Cashflow {
  id          String   @id @default(uuid())
  accountId   String
  type        String
  amount      Decimal
  description String?
  category    String?
  date        DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  account     Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([accountId])
  @@index([date])
  @@map("cashflow")
}

// ============================================
// COST OF GOODS SOLD (COGS)
// ============================================

model Batch {
  id          String   @id @default(uuid())
  sku         String
  accountId   String
  quantity    Int
  unitCost    Decimal
  totalCost   Decimal
  receivedAt  DateTime @default(now())
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  account     Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  cogs        COGS[]

  @@index([accountId])
  @@index([sku])
  @@index([accountId, sku])
  @@index([receivedAt])
  @@map("batches")
}

enum CostMethod {
  BATCH
  TIME_PERIOD
  WEIGHTED_AVERAGE
}

model COGS {
  id            String     @id @default(uuid())
  sku           String
  accountId     String
  marketplaceId String?    // Links to Marketplace for accurate profit calculation
  batchId       String?    // Optional link to Batch
  quantity      Int
  unitCost      Decimal    // Cost per unit
  totalCost     Decimal    // Total cost (unitCost * quantity + shipmentCost)
  costMethod    CostMethod @default(WEIGHTED_AVERAGE)
  shipmentCost  Decimal?   // Optional inbound shipment cost
  purchaseDate  DateTime   @default(now())
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  // Relations
  account       Account    @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace   Marketplace? @relation(fields: [marketplaceId], references: [id], onDelete: SetNull)
  batch         Batch?     @relation(fields: [batchId], references: [id], onDelete: SetNull)

  @@index([accountId])
  @@index([sku])
  @@index([marketplaceId])
  @@index([batchId])
  @@index([accountId, sku])
  @@index([accountId, sku, marketplaceId])
  @@index([purchaseDate])
  @@index([accountId, sku, purchaseDate])
  @@map("cogs")
}

// ============================================
// ALERTS & NOTIFICATIONS
// ============================================

model Alert {
  id          String   @id @default(uuid())
  accountId   String?
  type        String
  severity    String   @default("info")
  title       String
  message     String
  isRead      Boolean  @default(false)
  metadata    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([accountId])
  @@index([isRead])
  @@index([type])
  @@map("alerts")
}

// ============================================
// REIMBURSEMENTS
// ============================================

model Reimbursement {
  id          String   @id @default(uuid())
  accountId   String
  orderId     String?
  type        String
  amount      Decimal
  status      String   @default("pending")
  description String?
  requestDate DateTime @default(now())
  processedDate DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([accountId])
  @@index([status])
  @@map("reimbursements")
}

model FbaInventoryAlert {
  id                String   @id @default(uuid())
  userId            String
  accountId         String?
  marketplaceId     String
  productId         String?
  sku               String?
  alertType         String   // 'lost' or 'damaged'
  reportedQuantity  Int      @default(0)
  reimbursedQuantity Int     @default(0)
  estimatedAmount   Decimal  @default(0)
  status            String   @default("pending") // 'pending', 'reimbursed', 'ignored', 'disputed'
  notes             String?
  detectedAt        DateTime @default(now())
  resolvedAt        DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  user              User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  account           Account?     @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace       Marketplace  @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)
  product           Product?     @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([accountId])
  @@index([marketplaceId])
  @@index([productId])
  @@index([sku])
  @@index([alertType])
  @@index([status])
  @@index([detectedAt])
  @@map("fba_inventory_alerts")
}

model RefundDiscrepancy {
  id                  String   @id @default(uuid())
  userId              String
  accountId           String?
  marketplaceId       String
  productId           String?
  sku                 String?
  refundQuantity      Int      @default(0)
  returnedQuantity    Int      @default(0)
  unreimbursedAmount  Decimal  @default(0)
  refundReasonCode    String?
  status              String   @default("pending") // 'pending', 'reconciled', 'ignored'
  detectedAt          DateTime @default(now())
  resolvedAt          DateTime?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // Relations
  user                User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  account             Account?     @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace         Marketplace  @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)
  product             Product?     @relation(fields: [productId], references: [id], onDelete: SetNull)
  history             RefundDiscrepancyHistory[]

  @@index([userId])
  @@index([accountId])
  @@index([marketplaceId])
  @@index([productId])
  @@index([sku])
  @@index([status])
  @@index([refundReasonCode])
  @@index([detectedAt])
  @@map("refund_discrepancies")
}

model RefundDiscrepancyHistory {
  id                String   @id @default(uuid())
  discrepancyId     String
  userId            String
  previousStatus    String?
  newStatus         String
  notes             String?
  changedAt         DateTime @default(now())
  metadata          Json?

  // Relations
  discrepancy       RefundDiscrepancy @relation(fields: [discrepancyId], references: [id], onDelete: Cascade)
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([discrepancyId])
  @@index([userId])
  @@index([changedAt])
  @@map("refund_discrepancy_history")
}

model ReimbursementCase {
  id               String   @id @default(uuid())
  userId           String
  accountId        String?
  marketplaceId    String
  productId        String?
  sku              String?
  caseType         String   // 'lost', 'damaged', 'refund_discrepancy'
  generatedText    String
  submissionStatus String   @default("draft") // 'draft', 'submitted', 'resolved'
  submissionDate   DateTime?
  resolutionDate   DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  user             User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  account          Account?     @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace      Marketplace  @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)
  product          Product?     @relation(fields: [productId], references: [id], onDelete: SetNull)
  history          CaseHistory[]

  @@index([userId])
  @@index([accountId])
  @@index([marketplaceId])
  @@index([productId])
  @@index([sku])
  @@index([caseType])
  @@index([submissionStatus])
  @@map("reimbursement_cases")
}

model CaseHistory {
  id             String   @id @default(uuid())
  caseId         String
  userId         String
  previousText   String?
  newText        String?
  previousStatus String?
  newStatus      String?
  notes          String?
  changedAt      DateTime @default(now())
  metadata       Json?

  // Relations
  case           ReimbursementCase @relation(fields: [caseId], references: [id], onDelete: Cascade)
  user           User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([caseId])
  @@index([userId])
  @@index([changedAt])
  @@map("case_history")
}

// ============================================
// REPORTS & ANALYTICS
// ============================================

model Report {
  id          String   @id @default(uuid())
  accountId   String?
  userId      String?
  type        String
  name        String
  parameters  Json?
  data        Json?
  status      String   @default("pending")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([accountId])
  @@index([userId])
  @@index([type])
  @@map("reports")
}

model ReportSchedule {
  id              String   @id @default(uuid())
  accountId       String
  userId          String
  reportType      String
  filters         Json?
  schedule        String   // daily, weekly, monthly
  emailRecipients String[]
  lastRunAt       DateTime?
  nextRunAt       DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  account         Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([accountId])
  @@index([userId])
  @@index([reportType])
  @@map("report_schedules")
}

// ============================================
// AUDIT & LOGGING
// ============================================

model AuditLog {
  id          String   @id @default(uuid())
  userId      String
  action      String
  entity      String?
  entityId    String?
  changes     Json?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([entity, entityId])
  @@index([createdAt])
  @@map("audit_logs")
}

model SyncLog {
  id              String   @id @default(uuid())
  userId          String
  amazonAccountId String
  syncType        String   // 'orders', 'fees', 'ppc', 'inventory', 'listings', 'refunds'
  status          String   // 'success', 'failed', 'partial'
  recordsSynced   Int      @default(0)
  recordsFailed   Int      @default(0)
  errorMessage    String?
  metadata        Json?    // Additional sync details
  startedAt       DateTime @default(now())
  completedAt     DateTime?

  // Relations
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  amazonAccount   AmazonAccount @relation(fields: [amazonAccountId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([amazonAccountId])
  @@index([syncType])
  @@index([startedAt])
  @@map("sync_logs")
}

// ============================================
// AMAZON ACCOUNTS (Linked Seller Central)
// ============================================

model AmazonAccount {
  id              String   @id @default(uuid())
  userId          String   // Internal user reference (seller_id)
  amazonSellerId  String   // Amazon's seller ID (e.g., A1B2C3D4E5F6G7)
  marketplace     String   // e.g. "US", "DE", "JP"
  sellerId        String   // Legacy field, kept for backward compatibility (same as amazonSellerId)
  
  // LWA (Login with Amazon) Credentials
  lwaClientId     String   // LWA Client ID (encrypted)
  lwaClientSecret String   // LWA Client Secret (encrypted)
  refreshToken    String   // LWA Refresh Token (encrypted) - NEVER expose to frontend
  
  // IAM Role for SP-API
  iamRoleArn      String?  // AWS IAM Role ARN for assuming role (e.g., arn:aws:iam::123456789012:role/SP-API-Role)

  // Webhook secret (per seller)
  webhookSecret   String?  // Webhook signing secret for this seller
  
  // Marketplace Configuration
  marketplaceIds  String[] // Array of marketplace IDs this seller has access to (e.g., ["ATVPDKIKX0DER", "A2EUQ1WTGCTBG2"])
  
  // AWS Region
  region          String   @default("us-east-1") // AWS region for SP-API calls (us-east-1, eu-west-1, etc.)
  
  // Legacy fields (kept for backward compatibility)
  accessKey       String?  // Encrypted (deprecated, use IAM role instead)
  secretKey       String?  // Encrypted (deprecated, use IAM role instead)
  
  // Status
  isActive        Boolean  @default(true)
  lastTokenRefreshAt DateTime? // Track when access token was last refreshed
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders       AmazonOrder[]
  ppcMetrics   PPCMetric[]
  inventory    AmazonInventory[]
  inventoryStock InventoryStock[]
  listingChanges ListingChange[]
  refunds      AmazonRefund[]
  syncLogs     SyncLog[]
  syncSchedules SyncSchedule[]
  orderImports OrderImportStaging[]
  ppcImports   PPCImportStaging[]
  inventoryImports InventoryImportStaging[]
  listingImports ListingImportStaging[]
  refundImports RefundImportStaging[]
  userMarketplaces UserMarketplace[]

  @@unique([userId, marketplace]) // Ensure unique linkage per user/marketplace combination
  @@index([userId])
  @@index([amazonSellerId])
  @@index([marketplace])
  @@index([isActive])
  @@map("amazon_accounts")
}

model AmazonOrder {
  id            String   @id @default(uuid())
  orderId       String   @unique
  marketplaceId String
  accountId     String   // Links to AmazonAccount.id or internal Account.id? Requirement says "Relationships: User -> AmazonAccount"
  // Requirement: "AmazonOrder model: orderId, marketplaceId, accountId, status, totalAmount, fees (json)"
  // I will link to AmazonAccount for credentials linkage + internal Account for business logic if needed. 
  // Requirement says "Relationships: User -> AmazonAccount -> Marketplace -> Orders" implying AmazonOrder links to AmazonAccount.
  amazonAccountId String
  
  status        String
  totalAmount   Decimal  @default(0)
  fees          Json?    // Stores broken down fees
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  amazonAccount AmazonAccount @relation(fields: [amazonAccountId], references: [id], onDelete: Cascade)
  items         AmazonOrderItem[]

  @@index([amazonAccountId])
  @@index([orderId])
  @@map("amazon_orders")
}

model AmazonOrderItem {
  id              String   @id @default(uuid())
  amazonOrderId   String   // Links to AmazonOrder.id
  orderItemId     String?  // Amazon's order item ID (OrderItemId from SP-API)
  asin            String?  // Product ASIN
  sellerSku       String?  // Seller SKU
  title           String?  // Product title
  quantityOrdered Int      @default(1)
  quantityShipped Int?     // Quantity shipped (may be null if not shipped yet)
  itemPrice       Decimal? // Unit price
  itemTax         Decimal? // Tax per item
  shippingPrice   Decimal? // Shipping price
  shippingTax     Decimal? // Shipping tax
  giftWrapPrice   Decimal? // Gift wrap price
  giftWrapTax     Decimal? // Gift wrap tax
  itemPromotionDiscount Decimal? // Promotion discount
  shippingPromotionDiscount Decimal? // Shipping promotion discount
  codFee          Decimal? // COD fee
  codFeeDiscount  Decimal? // COD fee discount
  currency        String?  // Currency code
  productInfo     Json?    // Additional product information (condition, gift message, etc.)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  amazonOrder     AmazonOrder @relation(fields: [amazonOrderId], references: [id], onDelete: Cascade)

  @@index([amazonOrderId])
  @@index([asin])
  @@index([sellerSku])
  @@index([orderItemId])
  @@unique([amazonOrderId, orderItemId]) // Ensure unique order item per order
  @@map("amazon_order_items")
}

model PPCMetric {
  id            String   @id @default(uuid())
  campaignId    String
  adGroupId     String?
  keywordId     String?
  
  clicks        Int      @default(0)
  spend         Decimal  @default(0)
  sales         Decimal  @default(0)
  acos          Decimal? 
  
  amazonAccountId String // Linked to AmazonAccount
  marketplaceId   String
  date          DateTime
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  amazonAccount AmazonAccount @relation(fields: [amazonAccountId], references: [id], onDelete: Cascade)

  @@index([amazonAccountId])
  @@index([campaignId])
  @@index([adGroupId])
  @@index([keywordId])
  @@index([date])
  @@index([amazonAccountId, date])
  @@map("ppc_metrics")
}

model PPCCampaign {
  id           String   @id @default(uuid())
  accountId    String
  marketplaceId String?
  campaignName String
  status       String   @default("active")
  totalSpend   Decimal  @default(0)
  totalSales   Decimal  @default(0)
  acos         Decimal  @default(0)
  roi          Decimal  @default(0)
  breakEvenAcos Decimal?
  estimatedProfit Decimal? @default(0)
  suggestedBid Decimal?
  lastCalculatedAt DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  account      Account      @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace  Marketplace? @relation(fields: [marketplaceId], references: [id], onDelete: SetNull)
  adGroups     PPCAdGroup[]

  @@index([accountId])
  @@index([marketplaceId])
  @@index([accountId, marketplaceId])
  @@map("ppc_dashboard_campaigns")
}

model PPCAdGroup {
  id           String   @id @default(uuid())
  campaignId   String
  accountId    String
  marketplaceId String?
  adGroupName  String
  status       String   @default("active")
  spend        Decimal  @default(0)
  sales        Decimal  @default(0)
  acos         Decimal  @default(0)
  roi          Decimal  @default(0)
  breakEvenAcos Decimal?
  estimatedProfit Decimal? @default(0)
  suggestedBid Decimal?
  lastCalculatedAt DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  campaign     PPCCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  account      Account     @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace  Marketplace? @relation(fields: [marketplaceId], references: [id], onDelete: SetNull)
  keywords     PPCKeyword[]

  @@index([campaignId])
  @@index([accountId])
  @@index([marketplaceId])
  @@map("ppc_dashboard_ad_groups")
}

model PPCKeyword {
  id           String   @id @default(uuid())
  adGroupId    String
  accountId    String
  marketplaceId String?
  keyword      String
  matchType    String?
  spend        Decimal  @default(0)
  sales        Decimal  @default(0)
  acos         Decimal  @default(0)
  roi          Decimal  @default(0)
  targetAcos   Decimal?
  targetProfitability Decimal?
  currentBid   Decimal  @default(0)
  suggestedBid Decimal?
  optimizationMode String @default("manual") // manual, autoplay
  status       String   @default("active") // active, paused, negative
  lastOptimizedAt DateTime?
  pendingBulkUpdate Json?
  lastBulkUpdatedAt DateTime?
  breakEvenAcos Decimal?
  estimatedProfit Decimal? @default(0)
  lastCalculatedAt DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  adGroup      PPCAdGroup  @relation(fields: [adGroupId], references: [id], onDelete: Cascade)
  account      Account     @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace  Marketplace? @relation(fields: [marketplaceId], references: [id], onDelete: SetNull)
  optimizationHistory PPCOptimizationHistory[]

  @@index([adGroupId])
  @@index([accountId])
  @@index([marketplaceId])
  @@index([keyword])
  @@map("ppc_dashboard_keywords")
}

model PPCBulkHistory {
  id         String   @id @default(uuid())
  userId     String
  accountId  String
  targetType String
  targetIds  Json
  actionType String
  oldValues  Json?
  newValues  Json?
  campaignId String?
  adGroupId  String?
  keywordId  String?
  createdAt  DateTime @default(now())

  // Relations
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  account    Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([accountId])
  @@index([campaignId])
  @@index([adGroupId])
  @@index([keywordId])
  @@map("ppc_bulk_history")
}

model PPCOptimizationHistory {
  id         String   @id @default(uuid())
  keywordId  String
  previousBid Decimal?
  newBid     Decimal?
  reason     String
  createdAt  DateTime @default(now())

  // Relations
  keyword    PPCKeyword @relation(fields: [keywordId], references: [id], onDelete: Cascade)

  @@index([keywordId])
  @@map("ppc_optimization_history")
}

model AmazonInventory {
  id            String   @id @default(uuid())
  sku           String
  marketplaceId String
  amazonAccountId String
  
  stockLevel    Int      @default(0)
  inboundQty    Int      @default(0)
  
  updatedAt     DateTime @updatedAt

  // Relations
  amazonAccount AmazonAccount @relation(fields: [amazonAccountId], references: [id], onDelete: Cascade)

  @@unique([amazonAccountId, sku, marketplaceId])
  @@map("amazon_inventory")
}

model ListingChange {
  id            String   @id @default(uuid())
  sku           String
  marketplaceId String
  amazonAccountId String
  
  changes       Json     // Details of what changed (price, buybox, title)
  detectedAt    DateTime @default(now())

  // Relations
  amazonAccount AmazonAccount @relation(fields: [amazonAccountId], references: [id], onDelete: Cascade)

  @@index([amazonAccountId])
  @@index([sku])
  @@map("listing_changes")
}

model ListingAlert {
  id                   String   @id @default(uuid())
  userId               String
  marketplaceId        String
  asin                 String
  sku                  String?
  previousTitle        String?
  newTitle             String?
  previousDescription  String?
  newDescription       String?
  previousImages       Json?
  newImages            Json?
  previousCategory     String?
  newCategory          String?
  newSellerDetected    Boolean  @default(false)
  status               String   @default("unread") // unread, read, resolved
  timestamp            DateTime @default(now())

  // Relations
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  marketplace          Marketplace @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)

  @@index([asin])
  @@index([sku])
  @@index([marketplaceId])
  @@index([userId])
  @@map("listing_alerts")
}

model ListingHistory {
  id            String   @id @default(uuid())
  marketplaceId String
  asin          String
  title         String?
  description   String?
  images        Json?
  category      String?
  sellers       Json?
  capturedAt    DateTime @default(now())

  // Relations
  marketplace   Marketplace @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)

  @@index([asin])
  @@index([marketplaceId])
  @@map("listing_history")
}

model BuyBoxAlert {
  id                String   @id @default(uuid())
  userId            String
  marketplaceId     String
  asin              String
  sku               String?
  lostBuyBox        Boolean  @default(false)
  previousPrice     Decimal?
  newPrice          Decimal?
  competitorChanges Json?
  status            String   @default("unread") // unread, read, resolved
  timestamp         DateTime @default(now())

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  marketplace       Marketplace @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)

  @@index([asin])
  @@index([sku])
  @@index([marketplaceId])
  @@index([userId])
  @@map("buybox_alerts")
}

model BuyBoxHistory {
  id            String   @id @default(uuid())
  marketplaceId String
  asin          String
  sku           String?
  buyBoxOwner   String?
  price         Decimal?
  competitorData Json?
  capturedAt    DateTime @default(now())

  // Relations
  marketplace   Marketplace @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)

  @@index([asin])
  @@index([sku])
  @@index([marketplaceId])
  @@map("buybox_history")
}

model FeeChangeAlert {
  id               String   @id @default(uuid())
  userId           String
  marketplaceId    String
  productId        String?
  sku              String?
  feeType          String
  previousFee      Decimal?
  newFee           Decimal?
  changePercentage Decimal?
  status           String   @default("unread") // unread, read, resolved
  timestamp        DateTime @default(now())

  // Relations
  user             User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  marketplace      Marketplace @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)
  product          Product?    @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@index([marketplaceId])
  @@index([productId])
  @@index([sku])
  @@index([userId])
  @@map("fee_change_alerts")
}

model FeeChangeHistory {
  id            String   @id @default(uuid())
  marketplaceId String
  productId     String?
  sku           String?
  feeType       String
  feeAmount     Decimal
  capturedAt    DateTime @default(now())

  // Relations
  marketplace   Marketplace @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)
  product       Product?    @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@index([marketplaceId])
  @@index([productId])
  @@index([sku])
  @@map("fee_change_history")
}

model FeedbackReviewAlert {
  id             String   @id @default(uuid())
  userId         String
  marketplaceId  String
  asin           String?
  productId      String?
  sku            String?
  previousRating Decimal?
  newRating      Decimal?
  reviewText     String?
  reviewer       String?
  status         String   @default("unread") // unread, read, resolved
  timestamp      DateTime @default(now())

  // Relations
  user           User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  marketplace    Marketplace @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)
  product        Product?    @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@index([asin])
  @@index([marketplaceId])
  @@index([userId])
  @@index([productId])
  @@index([sku])
  @@map("feedback_review_alerts")
}

model FeedbackReviewHistory {
  id            String   @id @default(uuid())
  marketplaceId String
  asin          String?
  productId     String?
  sku           String?
  rating        Decimal?
  reviewText    String?
  reviewer      String?
  capturedAt    DateTime @default(now())

  // Relations
  marketplace   Marketplace @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)
  product       Product?    @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@index([asin])
  @@index([marketplaceId])
  @@index([productId])
  @@index([sku])
  @@map("feedback_review_history")
}

model EmailTemplate {
  id            String   @id @default(uuid())
  userId        String
  name          String
  subject       String
  body          String
  variables     Json?
  marketplaceId String?
  productId     String?
  sku           String?
  purchaseType  String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  marketplace   Marketplace? @relation(fields: [marketplaceId], references: [id], onDelete: SetNull)
  product       Product?    @relation(fields: [productId], references: [id], onDelete: SetNull)
  queue         EmailQueue[]
  schedulingRules SchedulingRule[]
  reviewStats ReviewStats[]

  @@index([userId])
  @@index([marketplaceId])
  @@index([productId])
  @@map("email_templates")
}

model EmailQueue {
  id             String   @id @default(uuid())
  templateId     String
  recipientEmail String
  eventKey       String?
  scheduledAt    DateTime
  sentAt         DateTime?
  status         String   @default("pending") // pending, sent, failed
  openedCount    Int      @default(0)
  clickedCount   Int      @default(0)
  responseCount  Int      @default(0)
  errorMessage   String?
  payload        Json?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  template       EmailTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  interactions   EmailInteraction[]

  @@index([templateId])
  @@index([status])
  @@index([eventKey])
  @@map("email_queue")
}

model EmailInteraction {
  id            String   @id @default(uuid())
  emailQueueId  String
  eventType     String   // 'open', 'click', 'bounce', 'delivered'
  timestamp     DateTime @default(now())
  metadata      Json?    // e.g., { clickedLink: 'https://...', userAgent: '...', ipAddress: '...' }
  createdAt     DateTime @default(now())

  // Relations
  emailQueue    EmailQueue @relation(fields: [emailQueueId], references: [id], onDelete: Cascade)

  @@index([emailQueueId])
  @@index([eventType])
  @@index([timestamp])
  @@map("email_interactions")
}

model ReviewStats {
  id                  String   @id @default(uuid())
  templateId          String
  userId              String
  accountId           String?
  marketplaceId       String?
  productId           String?
  asin                String?
  sku                 String?
  sentCount           Int      @default(0)
  reviewReceivedCount Int      @default(0)
  positiveReviews     Int      @default(0)
  negativeReviews     Int      @default(0)
  responseTimes       Json?    // { min: number, max: number, average: number } in hours
  lastUpdated         DateTime @default(now())
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // Relations
  template            EmailTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  user                User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  account             Account?      @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace         Marketplace?  @relation(fields: [marketplaceId], references: [id], onDelete: SetNull)
  product             Product?      @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@index([templateId])
  @@index([userId])
  @@index([accountId])
  @@index([marketplaceId])
  @@index([productId])
  @@index([asin])
  @@index([sku])
  @@unique([templateId, productId, asin, sku, accountId, marketplaceId])
  @@map("review_stats")
}

model SchedulingRule {
  id              String   @id @default(uuid())
  templateId      String
  userId          String
  accountId       String?
  marketplaceId   String?
  productId       String?
  sku             String?
  deliveryDelayDays Int    @default(0) // Days to wait after delivery before sending
  conditions      Json?   // JSON object with conditions: { firstTimeBuyer: true, notReturned: true, etc. }
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  template        EmailTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  account         Account?     @relation(fields: [accountId], references: [id], onDelete: Cascade)
  marketplace     Marketplace? @relation(fields: [marketplaceId], references: [id], onDelete: SetNull)
  product         Product?     @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@index([templateId])
  @@index([userId])
  @@index([accountId])
  @@index([marketplaceId])
  @@index([productId])
  @@index([isActive])
  @@map("scheduling_rules")
}

model AmazonRefund {
  id            String   @id @default(uuid())
  orderId       String   // Amazon order ID
  refundId      String   @unique
  amount        Decimal  @default(0)
  reasonCode    String?
  accountId     String   // Links to AmazonAccount
  marketplaceId String
  processedAt   DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  amazonAccount AmazonAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([accountId])
  @@index([orderId])
  @@index([marketplaceId])
  @@map("amazon_refunds")
}

// ============================================
// MANUAL DATA IMPORT STAGING TABLES
// ============================================

model OrderImportStaging {
  id            String   @id @default(uuid())
  userId        String
  amazonAccountId String
  marketplaceId String
  rawData       Json     // Parsed CSV/Excel row data
  validated     Boolean  @default(false)
  errorMessages Json?    // Array of validation errors
  status        String   @default("pending") // pending, approved, rejected, finalized
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  amazonAccount AmazonAccount @relation(fields: [amazonAccountId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([amazonAccountId])
  @@index([status])
  @@index([createdAt])
  @@map("order_import_staging")
}

model PPCImportStaging {
  id            String   @id @default(uuid())
  userId        String
  amazonAccountId String
  marketplaceId String
  rawData       Json
  validated     Boolean  @default(false)
  errorMessages Json?
  status        String   @default("pending")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  amazonAccount AmazonAccount @relation(fields: [amazonAccountId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([amazonAccountId])
  @@index([status])
  @@index([createdAt])
  @@map("ppc_import_staging")
}

model InventoryImportStaging {
  id            String   @id @default(uuid())
  userId        String
  amazonAccountId String
  marketplaceId String
  rawData       Json
  validated     Boolean  @default(false)
  errorMessages Json?
  status        String   @default("pending")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  amazonAccount AmazonAccount @relation(fields: [amazonAccountId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([amazonAccountId])
  @@index([status])
  @@index([createdAt])
  @@map("inventory_import_staging")
}

model ListingImportStaging {
  id            String   @id @default(uuid())
  userId        String
  amazonAccountId String
  marketplaceId String
  rawData       Json
  validated     Boolean  @default(false)
  errorMessages Json?
  status        String   @default("pending")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  amazonAccount AmazonAccount @relation(fields: [amazonAccountId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([amazonAccountId])
  @@index([status])
  @@index([createdAt])
  @@map("listing_import_staging")
}

model RefundImportStaging {
  id            String   @id @default(uuid())
  userId        String
  amazonAccountId String
  marketplaceId String
  rawData       Json
  validated     Boolean  @default(false)
  errorMessages Json?
  status        String   @default("pending")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  amazonAccount AmazonAccount @relation(fields: [amazonAccountId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([amazonAccountId])
  @@index([status])
  @@index([createdAt])
  @@map("refund_import_staging")
}

// ============================================
// OAUTH STATE (for CSRF protection)
// ============================================

model OAuthState {
  id          String   @id @default(uuid())
  userId      String   @map("userId")
  state       String   @unique // CSRF token
  redirectUri String   @map("redirectUri")
  marketplace String?  // Optional marketplace filter
  expiresAt   DateTime @map("expiresAt")
  createdAt   DateTime @default(now()) @map("createdAt")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("oauth_states")
  @@index([state])
  @@index([userId])
  @@index([expiresAt])
}

// ============================================
// SYNC SCHEDULES (per-account sync configuration)
// ============================================

model SyncSchedule {
  id              String   @id @default(uuid())
  amazonAccountId String
  userId          String
  syncType        String   // 'orders', 'fees', 'ppc', 'inventory', 'listings', 'refunds'
  intervalMinutes Int      @default(60) // Sync interval in minutes (0 = disabled)
  enabled         Boolean  @default(true)
  lastRunAt       DateTime? // Last time this sync type ran
  nextRunAt       DateTime? // Next scheduled run time
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  amazonAccount   AmazonAccount @relation(fields: [amazonAccountId], references: [id], onDelete: Cascade)
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([amazonAccountId, syncType]) // One schedule per account per sync type
  @@index([amazonAccountId])
  @@index([userId])
  @@index([enabled])
  @@index([nextRunAt])
  @@index([enabled, nextRunAt])
  @@map("sync_schedules")
}
